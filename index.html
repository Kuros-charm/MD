<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Markdown Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #welcome,
        #editor,
        #init {
            display: none;
        }

        textarea {
            width: 100%;
            height: 300px;
        }

        #preview {
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }

        .button {
            display: inline-block;
            padding: 10px 20px;
            margin: 10px 0;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            border: none;
            cursor: pointer;
        }

        .instructions {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="init" style="display: block;">
        <h1>Initialize</h1>

        <div class="instructions">
            <h2>How to Generate a GitHub Personal Access Token</h2>
            <ol>
                <li>Go to your GitHub account settings.</li>
                <li>Click on "Developer settings" in the left sidebar.</li>
                <li>Click on "Personal access tokens" and then "Tokens (classic)".</li>
                <li>Click "Generate new token" and select "Generate new token (classic)".</li>
                <li>Give your token a descriptive name.</li>
                <li>Select the following scopes:
                    <ul>
                        <li>repo (Full control of private repositories)</li>
                        <li>workflow (optional, if you plan to use GitHub Actions)</li>
                    </ul>
                </li>
                <li>Click "Generate token" at the bottom of the page.</li>
                <li>Copy your new personal access token immediately. You won't be able to see it again!</li>
            </ol>
            <p><strong>Important:</strong> Keep your token secure and don't share it. It provides access to your GitHub
                account.</p>
            <p><strong>Note:</strong> This application will create or use a public repository for GitHub Pages. Make
                sure you're comfortable with this before proceeding.</p>
        </div>

        <p>Set up your new password and GitHub API key:</p>
        <input type="password" id="newPassword" placeholder="New Password (min 16 characters)"><br><br>
        <input type="password" id="confirmPassword" placeholder="Confirm Password"><br><br>
        <input type="text" id="apiKey" placeholder="GitHub API Key (Personal Access Token)"><br><br>
        <input type="text" id="repoName" placeholder="Repository Name"><br><br>
        <button onclick="initialize()" class="button">Set Up</button>
    </div>

    <div id="welcome">
        <h1>Welcome to Secure Markdown Editor</h1>
        <p>Enter your password to decrypt and load your data:</p>
        <input type="password" id="password">
        <button onclick="decrypt()" class="button">Decrypt</button>
    </div>

    <div id="editor">
        <h1>Secure Markdown Editor</h1>
        <textarea id="markdown"></textarea>
        <button onclick="updatePreview()" class="button">Update Preview</button>
        <button onclick="save()" class="button">Save</button>
        <div id="preview"></div>
    </div>

    <script>
        let encryptedData = "KZaN95KPuOSaepcIqwoCo0t4lyTz6A6OAhsrJYLpyk5yIWM/TeFxEhwdwYMlhux7Q7aWlpcrry/cKEnmGnknKQo/nJ7gbLFA9rsUscBfStZz0Beb07/HvqU6LCgmiTvBy+G00Rlxf+mu5kDDFR5mzLwOIkRt7J6WmROcS7ciNFxZ3NkZRdMALrIuzQ==";
        let currentUser = "";

        // Load the initialization screen
        document.getElementById("init").style.display = "block";

        async function createRepository() {
            const apiKey = document.getElementById("apiKey").value;
            const repoName = document.getElementById("repoName").value;

            if (!apiKey || !repoName) {
                alert("Please enter both API Key and Repository Name.");
                return;
            }

            try {
                const repoPath = await ensurePublicRepository(apiKey, repoName);
                alert(`Repository created or updated successfully! Path: ${repoPath}`);
            } catch (error) {
                console.error("Error creating repository:", error);
                alert(`Failed to create repository: ${error.message}`);
            }
        }
        async function initialize() {
            const newPassword = document.getElementById("newPassword").value;
            const confirmPassword = document.getElementById("confirmPassword").value;
            const newApiKey = document.getElementById("apiKey").value;
            const repoName = document.getElementById("repoName").value;

            if (newPassword !== confirmPassword) {
                alert("Passwords do not match. Please try again.");
                return;
            }

            if (!isStrongPassword(newPassword)) {
                alert("Password must be at least 16 characters long and contain uppercase, lowercase, numbers, and special characters.");
                return;
            }

            if (!newPassword || !newApiKey || !repoName) {
                alert("Please fill in all fields.");
                return;
            }

            try {
                // Check if the repository exists and is public, or create a new public repository
                const repoPath = await ensurePublicRepository(newApiKey, repoName);

                // Encrypt the data
                const data = {
                    apiKey: newApiKey,
                    repoPath: repoPath,
                    markdown: ""
                };
                encryptedData = await encrypt(JSON.stringify(data), newPassword);

                // Update the HTML content
                const updatedHtml = document.documentElement.outerHTML
                    .replace(
                        /let encryptedData = "";/,
                        `let encryptedData = "${encryptedData}";`
                    );

                // Save the updated HTML file
                await saveToGitHub(updatedHtml, newApiKey, repoPath);

                // Enable GitHub Pages
                await enableGitHubPages(newApiKey, repoPath);

                alert("Initialization complete! Redirecting to your GitHub Pages site...");

                // Extract username and repo name from repoPath
                const [username, ] = repoPath.split('/');

                // Construct the GitHub Pages URL
                const githubPagesUrl = `https://${username}.github.io/${repoName}/`;

                // Redirect to the GitHub Pages URL
                window.location.href = githubPagesUrl;
            } catch (error) {
                console.error("Error during initialization:", error);
                alert(`Failed to complete initialization: ${error.message}`);
            }
        }

        async function getCurrentUser(token) {
            if (currentUser) return currentUser;

            const response = await fetch('https://api.github.com/user', {
                headers: {
                    'Authorization': `token ${token}`
                }
            });

            if (!response.ok) {
                throw new Error('Failed to fetch user information');
            }

            const userData = await response.json();
            currentUser = userData.login;
            return currentUser;
        }

        async function ensurePublicRepository(token, repoName) {
            const owner = await getCurrentUser(token);
            const repo = `${owner}/${repoName}`;
            const response = await fetch(`https://api.github.com/repos/${repo}`, {
                headers: {
                    'Authorization': `token ${token}`
                }
            });

            if (response.status === 404) {
                // Repository doesn't exist, create a new public repository
                const createResponse = await fetch(`https://api.github.com/user/repos`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: repoName,
                        private: false,
                        auto_init: true
                    })
                });

                if (!createResponse.ok) {
                    throw new Error("Failed to create public repository");
                }
                console.log("Public repository created successfully");
            } else if (response.ok) {
                // Repository exists, ensure it's public
                const repoData = await response.json();
                if (repoData.private) {
                    const updateResponse = await fetch(`https://api.github.com/repos/${repo}`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `token ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            private: false
                        })
                    });

                    if (!updateResponse.ok) {
                        throw new Error("Failed to make repository public");
                    }
                    console.log("Repository made public successfully");
                }
            } else {
                throw new Error("Failed to check repository status");
            }

            return repo;
        }

        async function saveToGitHub(content, token, repo) {
            const path = "index.html";
            const response = await fetch(`https://api.github.com/repos/${repo}/contents/${path}`, {
                headers: {
                    Authorization: `token ${token}`,
                },
            });
            const data = await response.json();

            // Commit the updated file to GitHub
            const commitResponse = await fetch(`https://api.github.com/repos/${repo}/contents/${path}`, {
                method: "PUT",
                headers: {
                    Authorization: `token ${token}`,
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    message: "Update Secure Markdown Editor",
                    content: btoa(content),
                    sha: data.sha,
                }),
            });

            if (!commitResponse.ok) {
                throw new Error("Failed to commit changes to GitHub");
            }

            console.log("Changes saved and committed to GitHub!");
        }

        async function enableGitHubPages(token, repo) {
            const response = await fetch(`https://api.github.com/repos/${repo}/pages`, {
                method: 'POST',
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.switcheroo-preview+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    source: {
                        branch: "main",
                        path: "/"
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Failed to enable GitHub Pages: ${errorData.message}`);
            }

            console.log("GitHub Pages enabled successfully!");
        }

        function isStrongPassword(password) {
            return password.length >= 16 && /[A-Z]/.test(password) && /[a-z]/.test(password) && /[0-9]/.test(password) && /[^A-Za-z0-9]/.test(password);
        }

        async function decrypt() {
            const password = document.getElementById("password").value;
            try {
                const decryptedData = await decryptData(encryptedData, password);
                const data = JSON.parse(decryptedData);
                document.getElementById("markdown").value = data.markdown;
                document.getElementById("welcome").style.display = "none";
                document.getElementById("editor").style.display = "block";
                updatePreview();
            } catch (error) {
                alert("Incorrect password. Please try again.");
            }
        }

        function updatePreview() {
            const markdown = document.getElementById("markdown").value;
            const preview = document.getElementById("preview");
            preview.innerHTML = marked.parse(markdown);
        }

        async function save() {
            const password = document.getElementById("password").value;
            const markdown = document.getElementById("markdown").value;
            try {
                const decryptedData = await decryptData(encryptedData, password);
                const data = JSON.parse(decryptedData);
                data.markdown = markdown;
                encryptedData = await encrypt(JSON.stringify(data), password);
                await saveToGitHub(document.documentElement.outerHTML, data.apiKey, data.repoPath);
                alert("Saved successfully!");
            } catch (error) {
                alert("Failed to save. Please try again.");
            }
        }

        async function encrypt(data, password) {
            const encoder = new TextEncoder();
            const encodedData = encoder.encode(data);
            const encodedPassword = encoder.encode(password);
            const key = await window.crypto.subtle.importKey(
                "raw",
                encodedPassword,
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const derivedKey = await window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                key,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encryptedContent = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                },
                derivedKey,
                encodedData
            );
            const encryptedArray = new Uint8Array(salt.byteLength + iv.byteLength + encryptedContent.byteLength);
            encryptedArray.set(salt, 0);
            encryptedArray.set(iv, salt.byteLength);
            encryptedArray.set(new Uint8Array(encryptedContent), salt.byteLength + iv.byteLength);
            return btoa(String.fromCharCode.apply(null, encryptedArray));
        }

        async function decryptData(encryptedData, password) {
            const encoder = new TextEncoder();
            const encodedPassword = encoder.encode(password);
            const encryptedArray = new Uint8Array(atob(encryptedData).split("").map(char => char.charCodeAt(0)));
            const salt = encryptedArray.slice(0, 16);
            const iv = encryptedArray.slice(16, 28);
            const data = encryptedArray.slice(28);
            const key = await window.crypto.subtle.importKey(
                "raw",
                encodedPassword,
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            const derivedKey = await window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                key,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
            const decryptedContent = await window.crypto.subtle.decrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                },
                derivedKey,
                data
            );
            const decoder = new TextDecoder();
            return decoder.decode(decryptedContent);
        }

        // Check if we're already initialized
        if (encryptedData) {
            document.getElementById("init").style.display = "none";
            document.getElementById("welcome").style.display = "block";
        }
    </script>


</body></html>